There was a special user to store backup files.
A script used somethink like "echo "password" | sudo -S -u backup.
Someone reported this and requested to decrypt passwort file with
GPG and then run cat $file | sudo -S -u backup. However this does
not help much, because where to store the key for GPG? Passing it
with echo to GPG? Same issue, just shifted!
However to avoid the passwort be directly visible in the script
of course we could store it XORed. Additionally, we can remove
read permissions from the binary file and make it setuid backup
(ahh no, they they want sudo instead and we start from scratch).
So I wrote a simple binary XOR obfuscating the passwort.
They didn't want to pay so here it is under LGPL...
------------------------------------------------------------------->8=======
/* Very poor password obfuscator to avoid passwort appearing in ps or top.
 * This is insecure. Transport key generation requires Linux.
 * [c] steffen@dett.de 2012. LGPLv1 only.
 * gcc -Wall -O0 -static cheap-sudopw.c -o cheap-sudopw */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* For XOR obfuscated transport key (weak). Adjust size as needed.
 * If its an empty array, the program generates one from /dev/random. */
char transport_key[16] = "";

/* The encrypted secrect. Generated by the program if empty.*/
char enc_password[] = "";


int main()
{
   if (!strlen(transport_key)) {
      char new_transport[sizeof(transport_key)];
      FILE *random = fopen("/dev/random", "r");
      if (!random)
         return EXIT_FAILURE;
      size_t read = fread(new_transport, 1, sizeof(transport_key), random);
      printf("Put this in the C code:\n"
         "char transport_key[%zu] = \"", sizeof(transport_key));
      for(size_t n=0; n<read; n++) {
         printf("\\x%02x", (unsigned char)new_transport[n]);
      }
      printf("\";\n");
      memcpy(transport_key, new_transport, sizeof(transport_key));
   }
   if (!strlen(enc_password)) {
      char password[100+1] = {0};
      char new_enc[100+1] = {0};
      printf("No encrypted password!\n"
         "Please pass up to %zu bytes clear text sceret to stdin\n",
         strlen(transport_key));
      size_t read = fread(password, 1, strlen(transport_key), stdin);
      password[read] = '\0';
      size_t n;
      for(n=0; n<read; n++) {
         new_enc[n] = password[n] ^ transport_key[n];
      }
      printf("Put this in the C code:\n"
         "char enc_password[] = \"");
      for(n=0; n<read; n++) {
         printf("\\x%02x", (unsigned char)new_enc[n]);
      }
      printf("\";\n");
      return EXIT_SUCCESS;
   }

   fflush(stdout);
   FILE *sudo = popen("sudo -S -u backup main.sh", "w");
   if (!sudo)
      return EXIT_FAILURE;
   {
      char password[100+1] = {0};
      for (size_t n=0; n<sizeof(enc_password)-1; n++)
         password[n] = enc_password[n] ^ transport_key[n];
      fprintf(sudo, "%s\n", password);
      for (size_t n=0; n<sizeof(enc_password)-1; n++)
         password[n] ^= transport_key[n];
   }
   fflush(sudo);
   int status = pclose(sudo);
   if(WIFEXITED(status)) {
      return WEXITSTATUS(status);
   }
   if(WIFSIGNALED(status))
      fprintf(stderr, "Terminated by signal: %i\n", WTERMSIG(status));
   return EXIT_FAILURE;
}
=======8<-------------------------------------------------------------------

