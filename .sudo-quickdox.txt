To store backup files with a special backup user using sudo without exposing
the passwort to ps, a wrapper is needed providing the key via a file or STDIN,
such as a script doing some:

   echo "password" | sudo -S -u backup.

Someone reported this and requested to decrypt passwort file with GPG:

  echo $gpgpass | \
    gpg --decrypt \
      --passphrase-fd 0 -q --no-verbose --no-comment
      encrypted_pass.ggp | \
        sudo -S -u backup

But now its the GPG passwort that appears in clear text in a script readable
by the executing user. Same issue, just shifted.

However to avoid the passwort be directly visible in the script of course we
could store it obfuscated, such as XORed. Additionally, we can remove read
permissions from the binary file and make it setuid backup (ahh no, they
they want sudo instead and we start from scratch).

This is not secure, it can be debugged easily

So I wrote a simple binary XOR obfuscating the passwort.
------------------------------------------------------------------->8=======
/* Very poor password obfuscator to avoid passwort appearing in ps or top.
 * This is insecure. Transport key generation requires Linux.
 * [c] Steffen.Dettmer@gmail.com 2012, 2019. LGPLv1 only.
 * gcc -Wall -Wextra -s -O0 -static cheap-sudopw.c -o cheap-sudopw */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* For XOR obfuscated transport key (weak). Adjust size as needed.
 * If its an empty array, the program generates one from /dev/urandom. */
char transport_key[16] = "";

/* The obfuscated secrect. Generated by the program if empty.*/
char obfuscated_password[] = "";


int main()
{
    /* Optionally generate a transport key. */
    if (!strlen(transport_key)) {
        char new_transport[sizeof(transport_key)];
        FILE *random = fopen("/dev/urandom", "r");
        if (!random) {
            return EXIT_FAILURE;
        }
        size_t read = fread(new_transport, 1, sizeof(transport_key), random);
        printf("Put this in the C code:\n"
            "char transport_key[%zu] = \"", sizeof(transport_key));
        for(size_t n=0; n<read; n++) {
            printf("\\x%02x", (unsigned char)new_transport[n]);
        }
        printf("\";\n");
        memcpy(transport_key, new_transport, sizeof(transport_key));
    }

    /* Optionally generate the obfuscated password. */
    if (!strlen(obfuscated_password)) {
        char password[100+1] = {0};
        char new_obfuscated[100+1] = {0};
        printf("No obfuscated password!\n"
            "Please pass up to %zu bytes clear text sceret to stdin\n",
            strlen(transport_key));
        size_t read = fread(password, 1, strlen(transport_key), stdin);
        password[read] = '\0';
        size_t n;
        for(n=0; n<read; n++) {
            new_obfuscated[n] = password[n] ^ transport_key[n];
        }
        printf("Put this in the C code:\n"
            "char obfuscated_password[] = \"");
        for(n=0; n<read; n++) {
            printf("\\x%02x", (unsigned char)new_obfuscated[n]);
        }
        printf("\";\n");
    }

    /* If we generated "source code", it must be copyied into this source
     * file and the final binary can be compiled. The code above actually
     * would not be needed but the disassemble look a bit better if there
     * are STDIN reads and /dev/random usage :) */
    if (!strlen(transport_key) || !strlen(obfuscated_password)) {
        return EXIT_SUCCESS;
    }

    /* Here the actual (and original) program begins. */
    fflush(stdout);
    FILE *sudo = popen("sudo -S -u backup backup.sh", "w");
    if (!sudo)
        return EXIT_FAILURE;
    {
        char password[100+1] = {0};
        for (size_t n=0; n<sizeof(obfuscated_password)-1; n++)
            password[n] = obfuscated_password[n] ^ transport_key[n];
        fprintf(sudo, "%s\n", password);
        for (size_t n=0; n<sizeof(obfuscated_password)-1; n++)
            password[n] ^= transport_key[n];
    }
    fflush(sudo);
    int status = pclose(sudo);
    if(WIFEXITED(status)) {
        return WEXITSTATUS(status);
    }
    if(WIFEXITED(status)) {
        fprintf(stderr, "Exit: %i\n", WEXITSTATUS(status));
    }
    if(WIFSIGNALED(status)) {
        fprintf(stderr, "Signal: %i\n", WTERMSIG(status));
    }
    return EXIT_FAILURE;
}
=======8<-------------------------------------------------------------------

